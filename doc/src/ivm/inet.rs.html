<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src\inet.rs`."><title>inet.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-fbd14db5c88ed452.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="ivm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (ec2f40c6b 2023-03-30)" data-search-js="search-bc5a112813b5d712.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../../static.files/storage-d4a1a279bad1a0c0.js"></script><script defer src="../../static.files/source-script-1b95b7cca98b26e5.js"></script><script defer src="../../source-files.js"></script><script defer src="../../static.files/main-9ade54abd4bd73c8.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../ivm/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
<a href="#523" id="523">523</a>
<a href="#524" id="524">524</a>
<a href="#525" id="525">525</a>
<a href="#526" id="526">526</a>
<a href="#527" id="527">527</a>
<a href="#528" id="528">528</a>
<a href="#529" id="529">529</a>
<a href="#530" id="530">530</a>
</pre><pre class="rust"><code><span class="kw">use crate</span>::{
  parser::ast::{
    Agent, AgentName, Connection, Connector, PortName, PortNameRef, ROOT_NODE_IDX, ROOT_PORT_NAME,
  },
  rule_book::{AgentId, RuleBook},
  util::sort_tuple,
};
<span class="kw">use </span>hashbrown::HashMap;
<span class="kw">use </span>itertools::Itertools;
<span class="kw">use </span>std::{
  fmt,
  ops::{Index, IndexMut},
  vec,
};

<span class="kw">pub type </span>NodeIdx = usize;
<span class="kw">pub type </span>PortIdx = usize;

<span class="doccomment">/// A node in the INet
</span><span class="attr">#[derive(Debug, Clone, Default)]
</span><span class="kw">pub struct </span>Node {
  <span class="doccomment">/// Unused nodes are available for reuse
  </span>used: bool,

  <span class="doccomment">/// Note: Has value ROOT_AGENT_ID by default
  </span><span class="kw">pub </span>agent_id: AgentId,

  <span class="doccomment">/// 0: principal port
  </span><span class="kw">pub </span>ports: Vec&lt;NodePort&gt;,

  <span class="kw">pub </span>agent_name: AgentName,
}

<span class="doccomment">/// A port in the INet
/// Note: (0, 0) is default
</span><span class="attr">#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
</span><span class="kw">pub struct </span>NodePort {
  <span class="kw">pub </span>node_idx: NodeIdx,
  <span class="kw">pub </span>port_idx: PortIdx,
}

<span class="kw">impl </span>fmt::Display <span class="kw">for </span>NodePort {
  <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; fmt::Result {
    <span class="macro">write!</span>(f, <span class="string">&quot;{:?}&quot;</span>, (<span class="self">self</span>.node_idx, <span class="self">self</span>.port_idx))
  }
}

<span class="doccomment">/// Construct a NodePort that can be used to index into INet
</span><span class="kw">pub fn </span>port(node_idx: NodeIdx, port_idx: PortIdx) -&gt; NodePort {
  NodePort { node_idx, port_idx }
}

<span class="doccomment">/// This represents the interaction net
</span><span class="attr">#[derive(Default, Debug, Clone)]
</span><span class="kw">pub struct </span>INet {
  <span class="kw">pub </span>nodes: Vec&lt;Node&gt;,
  free_nodes: Vec&lt;NodeIdx&gt;,
}

<span class="kw">impl </span>INet {
  <span class="doccomment">/// Allocate a new node
  </span><span class="kw">pub fn </span>new_node(<span class="kw-2">&amp;mut </span><span class="self">self</span>, agent_id: AgentId, port_count: usize) -&gt; NodeIdx {
    <span class="kw">let </span>node_idx = <span class="kw">match </span><span class="self">self</span>.free_nodes.pop() {
      <span class="prelude-val">Some</span>(node_idx) =&gt; node_idx,
      <span class="prelude-val">None </span>=&gt; {
        <span class="kw">let </span>node_idx = <span class="self">self</span>.nodes.len();
        <span class="self">self</span>.nodes.push(Default::default());
        node_idx
      }
    };

    <span class="kw">let </span>node = <span class="kw-2">&amp;mut </span><span class="self">self</span>[node_idx];
    node.used = <span class="bool-val">true</span>;
    node.agent_id = agent_id;
    node.ports = <span class="macro">vec!</span>[Default::default(); port_count];
    node_idx
  }

  <span class="doccomment">/// Make node available for reuse
  </span><span class="kw">pub fn </span>free_node(<span class="kw-2">&amp;mut </span><span class="self">self</span>, node_idx: NodeIdx) {
    <span class="self">self</span>[node_idx] = Default::default();
    <span class="self">self</span>.free_nodes.push(node_idx);
  }

  <span class="doccomment">/// Mutually link port
  </span><span class="kw">pub fn </span>link(<span class="kw-2">&amp;mut </span><span class="self">self</span>, a: NodePort, b: NodePort) {
    <span class="self">self</span>[a] = b;
    <span class="self">self</span>[b] = a;
  }

  <span class="doccomment">/// Validate the inet, panics if invalid, useful for debugging/tests
  /// If an INet generated from a valid AST fails validation, it&#39;s a bug
  </span><span class="kw">pub fn </span>validate(<span class="kw-2">&amp;</span><span class="self">self</span>) {
    <span class="kw">let </span><span class="kw-2">mut </span>used_node_count = <span class="number">0</span>;
    <span class="kw">for </span>(node_idx, node) <span class="kw">in </span><span class="self">self</span>.nodes.iter().enumerate() {
      <span class="kw">if </span>node.used {
        used_node_count += <span class="number">1</span>;

        <span class="macro">assert_ne!</span>(node.ports.len(), <span class="number">0</span>, <span class="string">&quot;Nodes must have at least one port:\n{node:#?}&quot;</span>);
        <span class="kw">for </span>port_idx <span class="kw">in </span><span class="number">0 </span>.. node.ports.len() {
          <span class="kw">let </span>src = port(node_idx, port_idx);
          <span class="kw">let </span>dst = <span class="self">self</span>[src];

          <span class="macro">assert_eq!</span>(<span class="self">self</span>[dst], src, <span class="string">&quot;\nNon-bidirectional link {:?}:\n{self:#?}&quot;</span>, (src, dst));

          <span class="macro">assert!</span>(<span class="self">self</span>[dst.node_idx].used, <span class="string">&quot;\nUsed node linked to unused node {:?}:\n{self:#?}&quot;</span>, (src, dst));
        }
      } <span class="kw">else </span>{
        <span class="macro">assert_eq!</span>(node.ports, <span class="macro">vec!</span>[]);
        <span class="macro">assert!</span>(<span class="self">self</span>.free_nodes.contains(<span class="kw-2">&amp;</span>node_idx), <span class="string">&quot;\n{self:#?}&quot;</span>);
      }
    }
    <span class="macro">assert!</span>(used_node_count &gt;= <span class="number">2</span>, <span class="string">&quot;Interaction net has {used_node_count} &lt; 2 nodes:\n{self:#?}&quot;</span>);
  }

  <span class="doccomment">/// Determines if a given node is part of an active pair and returns the other node in the pair
  </span><span class="kw">fn </span>node_is_part_of_active_pair(<span class="kw-2">&amp;</span><span class="self">self</span>, node_idx: NodeIdx) -&gt; <span class="prelude-ty">Option</span>&lt;NodeIdx&gt; {
    <span class="kw">let </span>dst = <span class="self">self</span>[port(node_idx, <span class="number">0</span>)];
    <span class="comment">// After validation, we can assume that dst.node_idx == node_idx
    </span>(dst.port_idx == <span class="number">0</span>).then_some(dst.node_idx)
  }

  <span class="doccomment">/// Determine active pairs that can potentially be rewritten if there is a matching rule
  </span><span class="kw">pub fn </span>active_pairs(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; ActivePairs {
    <span class="kw">let </span><span class="kw-2">mut </span>active_pairs = <span class="macro">vec!</span>[];
    <span class="kw">for </span>(node_idx, node) <span class="kw">in </span><span class="self">self</span>.nodes.iter().enumerate() {
      <span class="kw">if </span>!node.used {
        <span class="kw">continue</span>;
      }

      <span class="kw">if let </span><span class="prelude-val">Some</span>(dst_node_idx) = <span class="self">self</span>.node_is_part_of_active_pair(node_idx) {
        <span class="comment">// Only process each bidirectional link once, to prevent duplicates
        </span><span class="kw">if </span>node_idx &lt; dst_node_idx {
          active_pairs.push((node_idx, dst_node_idx));
        }
      }
    }
    active_pairs
  }

  <span class="doccomment">/// Rewrite active pair using rule book
  /// Returns new active pairs that were created during the rewrite
  /// Returns None if active pair could not be rewritten because there was no matching rule
  </span><span class="kw">fn </span>rewrite(<span class="kw-2">&amp;mut </span><span class="self">self</span>, (a, b): (NodeIdx, NodeIdx), rule_book: <span class="kw-2">&amp;</span>RuleBook) -&gt; <span class="prelude-ty">Option</span>&lt;ActivePairs&gt; {
    <span class="macro">debug_assert!</span>(
      <span class="self">self</span>[port(a, <span class="number">0</span>)] == port(b, <span class="number">0</span>) &amp;&amp; <span class="self">self</span>[port(b, <span class="number">0</span>)] == port(a, <span class="number">0</span>),
      <span class="string">&quot;Expected active pair: {:?}\n{self:#?}&quot;</span>,
      (a, b),
    );

    <span class="comment">// New active pairs can appear within the inserted sub-net or at the links between the sub-net and
    // the rest of the net. Of the pre-existing nodes, only the nodes whose principal port was linked
    // to an aux port of the active pair before the rewrite can become active pairs after the rewrite.

    // We need to determine which local nodes could form active pairs after this rewrite
    // The rewrite could connect aux ports of both A and B which could form an active pair
    // So initially we add those nodes as candidates whose principal port is connected to
    // an aux port of A or B. (Note that it&#39;s impossible that we accidentally add A or B
    // as candidates, because their principal ports are already connected to each other&#39;s.)
    // (Also note that we don&#39;t have to dedup A&#39;s and B&#39;s candidates, because each node
    // can only be a candidate once because it only has one principal port.)
    // After the rewrite, we add the nodes as candidates that were created during the rewrite.
    </span><span class="kw">let </span>active_pair_candidate_nodes = <span class="self">self</span>[a]
      .ports
      .iter()
      .skip(<span class="number">1</span>)
      .chain(<span class="self">self</span>[b].ports.iter().skip(<span class="number">1</span>))
      .filter(|port| port.port_idx == <span class="number">0</span>)
      .map(|port| port.node_idx)
      .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

    <span class="comment">/*
    The rewrite mechanism assumes that all wires between aux ports of the active pair
    and the rest of the net are unique. E.g. `A(a, a) ~ B` or `A(a) ~ B(a)` would be a problem.
    Our workaround: If the active pair contains two references to the same wire,
    we split the wire into two, by inserting a temporary intermediary node:
    E.g. `A(a, a) ~ B` becomes `A(a, b) ~ B, a ~ TMP(b)`
    E.g. `A(a) ~ B(a)` becomes `A(a) ~ B(b), a ~ TMP(b)`
    This is done by adding an intermediary node with two ports, one of which is linked to each
    of the two aux ports that were previously using the same wire (like a wire going through it).
    Then the rewrite is performed as usual, and afterwards the two ports of the intermediary
    node are linked together and the intermediary node is removed.
    */
    </span><span class="kw">const </span>INTERMEDIARY_AGENT_ID: AgentId = usize::MAX;
    <span class="kw">let </span><span class="kw-2">mut </span>intermediary_nodes = <span class="macro">vec!</span>[];
    <span class="kw">for </span>node_idx <span class="kw">in </span>[a, b] {
      <span class="kw">for </span>port_idx <span class="kw">in </span><span class="number">0 </span>.. <span class="self">self</span>[node_idx].ports.len() {
        <span class="kw">let </span>dst = <span class="self">self</span>[node_idx][port_idx];
        <span class="kw">if </span>dst.node_idx == a || dst.node_idx == b {
          <span class="comment">// Create intermediary node that will be removed after rewrite. It temporarily converts
          // the problematic self-link of the active pair into a link to another node,
          // which allows us to rewrite the active pair by assuming there are no self-links.
          // We link port 0 of TMP to src and port 1 of TMP to dst, to split the shared wire.
          </span><span class="kw">let </span>intermediary = <span class="self">self</span>.new_node(INTERMEDIARY_AGENT_ID, <span class="number">2</span>);
          <span class="kw">let </span>src = port(node_idx, port_idx);
          <span class="self">self</span>.link(src, port(intermediary, <span class="number">0</span>));
          <span class="self">self</span>.link(dst, port(intermediary, <span class="number">1</span>));
          intermediary_nodes.push(intermediary);
        }
      }
    }

    <span class="comment">// Apply rewrite rule to active pair if there is a matching rule
    </span><span class="kw">let </span>rule_application_result = rule_book.apply(<span class="self">self</span>, (a, b));

    <span class="comment">// Now that the rewrite is done (or no rewrite happened if there was no applicable rule),
    // we can remove the intermediary nodes and link their two wires together into one again.
    </span><span class="kw">for </span>node_idx <span class="kw">in </span>intermediary_nodes {
      <span class="kw">let </span>node = <span class="kw-2">&amp;</span><span class="self">self</span>[node_idx];
      <span class="kw">let </span>src = node[<span class="number">0</span>];
      <span class="kw">let </span>dst = node[<span class="number">1</span>];
      <span class="self">self</span>.link(src, dst);
      <span class="self">self</span>.free_node(node_idx);
    }

    <span class="kw">let </span>new_active_pairs = <span class="kw">if let </span><span class="prelude-val">Some</span>(created_nodes) = rule_application_result {
      <span class="comment">// Remove the nodes of the active pair that was rewritten
      </span><span class="self">self</span>.free_node(a);
      <span class="self">self</span>.free_node(b);

      <span class="comment">// Add nodes created by rewrite as candidates for new active pairs
      // There are no duplicates in this chained iter, because these sets are disjoint
      </span><span class="kw">let </span>active_pair_candidate_nodes = active_pair_candidate_nodes.into_iter().chain(created_nodes);

      <span class="comment">// Check which of the candidates actually form active pairs.
      // Sort each pair of node indices so that we can dedup them.
      // Sort the list of pairs so that we can dedup them.
      </span><span class="kw">let </span>new_active_pairs = active_pair_candidate_nodes
        .filter_map(|node_idx| {
          <span class="macro">debug_assert!</span>(<span class="self">self</span>[node_idx].used, <span class="string">&quot;Node {node_idx} is not used: {:#?}&quot;</span>, <span class="self">self</span>[node_idx]);
          <span class="self">self</span>.node_is_part_of_active_pair(node_idx).map(|dst_node_idx| {
            <span class="macro">debug_assert!</span>(
              <span class="self">self</span>[dst_node_idx].used,
              <span class="string">&quot;Node {dst_node_idx} is not used: {:#?}&quot;</span>,
              <span class="self">self</span>[dst_node_idx]
            );
            sort_tuple((node_idx, dst_node_idx))
          })
        })
        .sorted()
        .dedup()
        .collect_vec();
      <span class="prelude-val">Some</span>(new_active_pairs)
    } <span class="kw">else </span>{
      <span class="prelude-val">None </span><span class="comment">// No rewrite happened, so no new active pairs came into existence
    </span>};

    <span class="kw">if </span><span class="macro">cfg!</span>(debug_assertions) {
      <span class="self">self</span>.validate();
    }
    new_active_pairs
  }

  <span class="doccomment">/// Perform one reduction step
  </span><span class="kw">pub fn </span>reduce_step(<span class="kw-2">&amp;mut </span><span class="self">self</span>, rule_book: <span class="kw-2">&amp;</span>RuleBook) -&gt; bool {
    <span class="kw">for </span>active_pair <span class="kw">in </span><span class="self">self</span>.active_pairs() {
      <span class="kw">if </span><span class="self">self</span>.rewrite(active_pair, rule_book).is_some() {
        <span class="kw">return </span><span class="bool-val">true</span>;
      }
    }
    <span class="bool-val">false
  </span>}

  <span class="doccomment">/// Reduce net until no more reductions are possible, without rescanning for active pairs after each rewrite.
  /// Only scans the net for active pairs in the beginning. After each rewrite, new active pairs are found by
  /// checking the nodes involved in and adjacent to the rewritten sub-net.
  </span><span class="kw">pub fn </span>reduce_full(<span class="kw-2">&amp;mut </span><span class="self">self</span>, rule_book: <span class="kw-2">&amp;</span>RuleBook) -&gt; usize {
    <span class="kw">let </span><span class="kw-2">mut </span>active_pairs = <span class="self">self</span>.active_pairs();
    <span class="kw">let </span><span class="kw-2">mut </span>new_active_pairs = <span class="macro">vec!</span>[];
    <span class="kw">let </span><span class="kw-2">mut </span>reduction_count = <span class="number">0</span>;
    <span class="kw">while </span>!active_pairs.is_empty() {
      <span class="comment">// At this point, `new_active_pairs` is empty and `active_pairs` contains all currently active pairs
      </span><span class="kw">for </span>active_pair <span class="kw">in </span>active_pairs.drain(..) {
        <span class="kw">if let </span><span class="prelude-val">Some</span>(new_active_pairs_created_by_rewrite) = <span class="self">self</span>.rewrite(active_pair, rule_book) {
          new_active_pairs.extend(new_active_pairs_created_by_rewrite);
          reduction_count += <span class="number">1</span>;
        }
      }
      <span class="comment">// At this point, `active_pairs` is empty and `new_active_pairs` contains all new active pairs
      </span>active_pairs.extend(new_active_pairs.drain(..)); <span class="comment">// Reusing Vecs between iterations
    </span>}
    reduction_count
  }

  <span class="doccomment">/// Read back reduced net into textual form
  </span><span class="kw">pub fn </span>read_back(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;Connection&gt; {
    <span class="comment">// Helper function to generate new unique port names
    </span><span class="kw">let </span><span class="kw-2">mut </span>new_port_name = {
      <span class="kw">let </span><span class="kw-2">mut </span>next_port_idx = <span class="number">0</span>;
      <span class="kw">move </span>|| {
        <span class="kw">let </span>r = <span class="macro">format!</span>(<span class="string">&quot;_{}&quot;</span>, next_port_idx);
        next_port_idx += <span class="number">1</span>;
        r
      }
    };

    <span class="comment">// We use this to keep track of the names we give to agent aux ports
    </span><span class="kw">let </span><span class="kw-2">mut </span>nodes_aux_port_names = HashMap::&lt;NodeIdx, Vec&lt;PortName&gt;&gt;::new();

    <span class="comment">// Keep track of connections between ports
    </span><span class="kw">let </span><span class="kw-2">mut </span>connections = <span class="macro">vec!</span>[];

    <span class="comment">// Iterate over all active links
    </span><span class="kw">for </span>(node_idx, node) <span class="kw">in </span><span class="self">self</span>.nodes.iter().enumerate() {
      <span class="kw">if </span>!node.used {
        <span class="kw">continue</span>;
      }

      <span class="kw">for </span>port_idx <span class="kw">in </span><span class="number">0 </span>.. node.ports.len() {
        <span class="kw">let </span>src = port(node_idx, port_idx);
        <span class="kw">let </span>dst = <span class="self">self</span>[src];

        <span class="comment">// Only process each bidirectional link once, to prevent duplicates
        </span><span class="kw">if </span>src &lt; dst {
          <span class="doccomment">/// Build a `Connector` from a port. If the port is a principal port, the connector is an `Agent`.
          /// If the port is an aux port, the connector is a `Port`.
          </span><span class="kw">fn </span>build_connector_from_port(
            net: <span class="kw-2">&amp;</span>INet,
            node_idx_to_agent_port_names: <span class="kw-2">&amp;mut </span>HashMap&lt;NodeIdx, Vec&lt;PortName&gt;&gt;,
            <span class="kw-2">mut </span>new_port_name: <span class="kw">impl </span>FnMut() -&gt; String,
            node_port: NodePort,
          ) -&gt; Connector {
            <span class="kw">let </span>node = <span class="kw-2">&amp;</span>net[node_port.node_idx];
            <span class="comment">// Whenever we encounter a node we haven&#39;t seen before, we generate new unique aux port names for it.
            // When we encounter the same node again, we read the previously generated aux port names.
            // This ensures that all references to the same node use the same aux port names.
            </span><span class="kw">let </span>agent_aux_port_names = node_idx_to_agent_port_names
              .entry(node_port.node_idx)
              .or_insert_with(|| (<span class="number">1 </span>.. node.ports.len()).map(|<span class="kw">_</span>| new_port_name()).collect());

            <span class="kw">if </span>node_port.port_idx == <span class="number">0 </span>{
              <span class="comment">// Connected to a principal port, either `x ~ root` or `x ~ Agent(...)`
              </span><span class="kw">if </span>node_port.node_idx == ROOT_NODE_IDX {
                Connector::Port(ROOT_PORT_NAME.to_string())
              } <span class="kw">else </span>{
                Connector::Agent(Agent {
                  agent: node.agent_name.clone(),
                  ports: agent_aux_port_names.clone(),
                })
              }
            } <span class="kw">else </span>{
              <span class="comment">// Connected to auxiliary port of agent: `x ~ aux, Agent(..., aux, ...) ~ y`
              </span>Connector::Port(agent_aux_port_names[node_port.port_idx - <span class="number">1</span>].clone())
            }
          }

          <span class="comment">// For each link, we create a `Connection`: src ~ dst
          </span><span class="kw">let </span>src = build_connector_from_port(<span class="self">self</span>, <span class="kw-2">&amp;mut </span>nodes_aux_port_names, <span class="kw-2">&amp;mut </span>new_port_name, src);
          <span class="kw">let </span>dst = build_connector_from_port(<span class="self">self</span>, <span class="kw-2">&amp;mut </span>nodes_aux_port_names, <span class="kw-2">&amp;mut </span>new_port_name, dst);
          connections.push(Connection::new(src, dst));
        }
      }
    }
    connections
  }

  <span class="doccomment">/// Add a `Connector` to the net
  /// If the connector is a port, `Err(port_name)` is returned so that it can be linked later.
  /// If the connector is an agent, it is added as a new node and its principal port is returned as `Ok(port)`.
  /// Connections to auxiliary ports are added to `deferred_port_links` so that they can be linked later.
  </span><span class="kw">fn </span>add_connector&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>: <span class="lifetime">&#39;a</span>&gt;(
    <span class="kw-2">&amp;mut </span><span class="self">self</span>,
    connector: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>Connector,
    deferred_port_links: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>MaybeLinkedPorts&lt;<span class="lifetime">&#39;b</span>&gt;,
    agent_name_to_id: <span class="kw-2">&amp;</span>HashMap&lt;AgentName, AgentId&gt;,
    created_nodes: <span class="kw-2">&amp;mut </span>CreatedNodes,
  ) -&gt; MaybeLinkedPort&lt;<span class="lifetime">&#39;b</span>&gt; {
    <span class="kw">match </span>connector {
      Connector::Agent(agent) =&gt; {
        <span class="comment">// Create agent node
        </span><span class="kw">let </span>agent_name = agent.agent.clone();
        <span class="kw">let </span>Agent { agent, ports } = agent;
        <span class="kw">let </span>agent_id = agent_name_to_id[agent];
        <span class="kw">let </span>node_idx = <span class="self">self</span>.new_node(agent_id, <span class="number">1 </span>+ ports.len());
        <span class="self">self</span>[node_idx].agent_name = agent_name;

        <span class="kw">for </span>(i, port_name) <span class="kw">in </span>ports.iter().enumerate() {
          <span class="kw">let </span>port = port(node_idx, <span class="number">1 </span>+ i); <span class="comment">// +1 to skip principal port

          // Queue up connection to link it later
          </span>deferred_port_links.push([<span class="prelude-val">Err</span>(port_name), <span class="prelude-val">Ok</span>(port)]);
        }

        <span class="comment">// Keep track of created nodes so that we can determine active pairs created by this rewrite
        </span>created_nodes.push(node_idx);

        <span class="comment">// An agent node has no deps so it can always be created.
        // Return principal port of the created agent node in this net
        </span><span class="prelude-val">Ok</span>(port(node_idx, <span class="number">0</span>))
      }
      Connector::Port(port) =&gt; <span class="prelude-val">Err</span>(port), <span class="comment">// Can only be linked later
    </span>}
  }

  <span class="doccomment">/// Add connections to the net, either when creating a net from scratch or inserting a sub-net
  /// during a rewrite. `external_ports` is a map from port names to ports in the parent net.
  /// When creating a net from scratch, `external_ports` only contains the `root` port.
  /// When called by `RuleBook::apply`, `external_ports` contains the ports of the parent net that
  /// the rule&#39;s RHS sub-net is connected to, based on which INet ports the rule&#39;s LHS (active pair)
  /// aux port names map to, in that context of the local rewrite.
  </span><span class="kw">pub fn </span>add_connections&lt;<span class="lifetime">&#39;a</span>&gt;(
    <span class="kw-2">&amp;mut </span><span class="self">self</span>,
    connections: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[Connection],
    external_ports: MaybeLinkedPorts&lt;<span class="lifetime">&#39;a</span>&gt;,
    agent_name_to_id: <span class="kw-2">&amp;</span>HashMap&lt;AgentName, AgentId&gt;,
  ) -&gt; CreatedNodes {
    <span class="doccomment">/// Follow connections to find the target of a `port_name` that it resolves to.
    /// Returns `Ok(port)` if the target port could be found, `Err(port_name)` otherwise.
    /// Connections are removed (consumed) from `deferred_port_links` as they are followed.
    /// E.g. if `deferred_port_links` is `[Err(&quot;x&quot;) ~ Err(&quot;y&quot;), Err(&quot;y&quot;) ~ port]` and `port_name` is &quot;x&quot;,
    /// `Ok(port)` is returned and `deferred_port_links` is updated to `[]` as the followed links were consumed.
    /// As long as `deferred_port_links` is not empty, there are still unresolved ports to be linked.
    </span><span class="kw">fn </span>port_target&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>: <span class="lifetime">&#39;a</span>&gt;(
      deferred_port_links: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>MaybeLinkedPorts&lt;<span class="lifetime">&#39;b</span>&gt;,
      port_name: PortNameRef&lt;<span class="lifetime">&#39;b</span>&gt;,
    ) -&gt; MaybeLinkedPort&lt;<span class="lifetime">&#39;b</span>&gt; {
      <span class="kw">let </span><span class="kw-2">mut </span>target: MaybeLinkedPort = <span class="prelude-val">Err</span>(port_name);
      <span class="kw">while let </span><span class="prelude-val">Some</span>((i, connector)) = deferred_port_links.iter().enumerate().find_map(|(i, [lhs, rhs])| {
        <span class="kw">if </span>lhs == <span class="kw-2">&amp;</span>target {
          <span class="prelude-val">Some</span>((i, <span class="kw-2">*</span>rhs))
        } <span class="kw">else if </span>rhs == <span class="kw-2">&amp;</span>target {
          <span class="prelude-val">Some</span>((i, <span class="kw-2">*</span>lhs))
        } <span class="kw">else </span>{
          <span class="prelude-val">None
        </span>}
      }) {
        <span class="comment">// Found connection target of `port_name`, remove the connection
        </span><span class="kw">let _ </span>= deferred_port_links.swap_remove(i);

        target = connector;
        <span class="kw">if </span>target.is_ok() {
          <span class="kw">break</span>;
          <span class="comment">// If the connector is `Err(port_name)`, continue looking up further
        </span>}
      }
      target
    }

    <span class="comment">// We keep track of connections that are not linked together yet, as unordered pairs of ports.
    // Unlinked ports are represented by Err(name), linked ports by Ok(port).
    // We pre-populate `deferred_port_links` with `external_ports`:
    </span><span class="kw">let </span><span class="kw-2">mut </span>deferred_port_links = external_ports;

    <span class="kw">let </span><span class="kw-2">mut </span>created_nodes = <span class="macro">vec!</span>[];

    <span class="comment">// Add all connectors of all connections to `deferred_port_links`
    </span><span class="kw">for </span>Connection { lhs, rhs } <span class="kw">in </span>connections {
      <span class="kw">let </span>lhs = <span class="self">self</span>.add_connector(<span class="kw-2">&amp;</span>lhs, <span class="kw-2">&amp;mut </span>deferred_port_links, agent_name_to_id, <span class="kw-2">&amp;mut </span>created_nodes);
      <span class="kw">let </span>rhs = <span class="self">self</span>.add_connector(<span class="kw-2">&amp;</span>rhs, <span class="kw-2">&amp;mut </span>deferred_port_links, agent_name_to_id, <span class="kw-2">&amp;mut </span>created_nodes);
      deferred_port_links.push([lhs, rhs]);
    }
    <span class="comment">// At this point, `deferred_port_links` contains all pairs of ports that still need to be linked

    // Link all pairs of ports that could not be linked yet
    </span><span class="kw">while let </span><span class="prelude-val">Some</span>([lhs, rhs]) = deferred_port_links.pop() {
      <span class="kw">match </span>(lhs, rhs) {
        (<span class="prelude-val">Ok</span>(lhs), <span class="prelude-val">Ok</span>(rhs)) =&gt; {
          <span class="comment">// Both connectors are ready to be linked
          </span><span class="self">self</span>.link(lhs, rhs);
        }
        (<span class="prelude-val">Ok</span>(node_port), <span class="prelude-val">Err</span>(port_name)) | (<span class="prelude-val">Err</span>(port_name), <span class="prelude-val">Ok</span>(node_port)) =&gt; {
          <span class="comment">// Look up the connection target of `port_name` and queue the connection for later linking
          </span><span class="kw">let </span>target = port_target(<span class="kw-2">&amp;mut </span>deferred_port_links, port_name);
          deferred_port_links.push([target, <span class="prelude-val">Ok</span>(node_port)]);
        }
        (<span class="prelude-val">Err</span>(lhs), <span class="prelude-val">Err</span>(rhs)) =&gt; {
          <span class="comment">// Look up the connection target of both connectors, and queue the connection for later linking
          </span><span class="kw">let </span>lhs = port_target(<span class="kw-2">&amp;mut </span>deferred_port_links, lhs);
          <span class="kw">let </span>rhs = port_target(<span class="kw-2">&amp;mut </span>deferred_port_links, rhs);
          deferred_port_links.push([lhs, rhs]);
        }
      }
    }

    created_nodes
  }
}

<span class="kw">pub type </span>CreatedNodes = Vec&lt;NodeIdx&gt;;

<span class="doccomment">/// Represents a connection between two ports for deferred linking
/// Either Ok(port) or Err(port_name) which needs to be looked up later
</span><span class="kw">type </span>MaybeLinkedPort&lt;<span class="lifetime">&#39;a</span>&gt; = <span class="prelude-ty">Result</span>&lt;NodePort, PortNameRef&lt;<span class="lifetime">&#39;a</span>&gt;&gt;;
<span class="kw">type </span>MaybeLinkedPorts&lt;<span class="lifetime">&#39;a</span>&gt; = Vec&lt;[MaybeLinkedPort&lt;<span class="lifetime">&#39;a</span>&gt;; <span class="number">2</span>]&gt;;

<span class="kw">type </span>ActivePairs = Vec&lt;(NodeIdx, NodeIdx)&gt;;

<span class="comment">// Indexing utils to allow indexing an INet with a NodeIdx and NodePort

</span><span class="kw">impl </span>Index&lt;NodeIdx&gt; <span class="kw">for </span>INet {
  <span class="kw">type </span>Output = Node;

  <span class="kw">fn </span>index(<span class="kw-2">&amp;</span><span class="self">self</span>, idx: NodeIdx) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span>::Output {
    <span class="kw-2">&amp;</span><span class="self">self</span>.nodes[idx]
  }
}

<span class="kw">impl </span>IndexMut&lt;NodeIdx&gt; <span class="kw">for </span>INet {
  <span class="kw">fn </span>index_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>, idx: NodeIdx) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self</span>::Output {
    <span class="kw-2">&amp;mut </span><span class="self">self</span>.nodes[idx]
  }
}

<span class="kw">impl </span>Index&lt;PortIdx&gt; <span class="kw">for </span>Node {
  <span class="kw">type </span>Output = NodePort;

  <span class="kw">fn </span>index(<span class="kw-2">&amp;</span><span class="self">self</span>, idx: PortIdx) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span>::Output {
    <span class="kw-2">&amp;</span><span class="self">self</span>.ports[idx]
  }
}

<span class="kw">impl </span>IndexMut&lt;PortIdx&gt; <span class="kw">for </span>Node {
  <span class="kw">fn </span>index_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>, idx: PortIdx) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self</span>::Output {
    <span class="kw-2">&amp;mut </span><span class="self">self</span>.ports[idx]
  }
}

<span class="kw">impl </span>Index&lt;NodePort&gt; <span class="kw">for </span>INet {
  <span class="kw">type </span>Output = NodePort;

  <span class="kw">fn </span>index(<span class="kw-2">&amp;</span><span class="self">self</span>, idx: NodePort) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span>::Output {
    <span class="kw-2">&amp;</span><span class="self">self</span>[idx.node_idx][idx.port_idx]
  }
}

<span class="kw">impl </span>IndexMut&lt;NodePort&gt; <span class="kw">for </span>INet {
  <span class="kw">fn </span>index_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>, idx: NodePort) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self</span>::Output {
    <span class="kw-2">&amp;mut </span><span class="self">self</span>[idx.node_idx][idx.port_idx]
  }
}
</code></pre></div></section></main></body></html>
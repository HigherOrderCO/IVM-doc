<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src\rule_book.rs`."><title>rule_book.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-fbd14db5c88ed452.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="ivm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (ec2f40c6b 2023-03-30)" data-search-js="search-bc5a112813b5d712.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../../static.files/storage-d4a1a279bad1a0c0.js"></script><script defer src="../../static.files/source-script-1b95b7cca98b26e5.js"></script><script defer src="../../source-files.js"></script><script defer src="../../static.files/main-9ade54abd4bd73c8.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../ivm/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
</pre><pre class="rust"><code><span class="kw">use crate</span>::{
  error::ProgramErrors,
  inet::{CreatedNodes, INet, NodeIdx},
  parser::ast::{ActivePair, AgentName, Connection, PortName, Rule},
  util::sort_tuples_by_fst,
};
<span class="kw">use </span>chumsky::prelude::Rich;
<span class="kw">use </span>derive_new::new;
<span class="kw">use </span>hashbrown::HashMap;
<span class="kw">use </span>itertools::Itertools;

<span class="doccomment">/// Agent IDs start from 1, 0 is reserved for the root node&#39;s agent_id
</span><span class="kw">pub type </span>AgentId = usize;

<span class="doccomment">/// Agent ID 0 is reserved for the root
</span><span class="kw">pub const </span>ROOT_AGENT_ID: AgentId = <span class="number">0</span>;

<span class="doccomment">/// Ordered pair of AgentIds represents active pair
/// So that we only have to store one mapping to cover A ~ B and B ~ A
</span><span class="kw">type </span>RuleLhs = (AgentId, AgentId);

<span class="kw">struct </span>RuleRhs {
  rule_src: String, <span class="comment">// Rule&#39;s source code, used for showing in error messages
  </span>port_idx_to_name: [Vec&lt;PortName&gt;; <span class="number">2</span>],
  connections: Vec&lt;Connection&gt;,
}

<span class="doccomment">/**
The rule book is a mapping from active pair to a rule&#39;s RHS connections.
E.g. if we have: rule Add(ret, a) ~ Succ(b) = ret ~ Succ(cnt), Add(cnt, a) ~ b
then the rule book maps (Add, Succ) to [ret ~ Succ(cnt), Add(cnt, a) ~ b]
which is a sub-net in which the ports that are named in the active pair
appear as external links (i.e. not connected to any other ports in the sub-net).
During rule application, the rule RHS sub-net is constructed and external links
are connected to the corresponding ports in the active pair of the net.
Currently the ports are linked by name, but this could be changed to use port ids.
*/
</span><span class="attr">#[derive(new)]
</span><span class="kw">pub struct </span>RuleBook {
  <span class="kw">pub </span>agent_name_to_id: HashMap&lt;AgentName, AgentId&gt;,
  <span class="attr">#[new(default)]
  </span>rules: HashMap&lt;RuleLhs, RuleRhs&gt;,
}

<span class="kw">impl </span>RuleBook {
  <span class="doccomment">/// Insert into rule book and check for duplicate rules
  </span><span class="kw">pub fn </span>add_rule(<span class="kw-2">&amp;mut </span><span class="self">self</span>, rule: <span class="kw-2">&amp;</span>Rule, rule_src: <span class="kw-2">&amp;</span>str, errors: <span class="kw-2">&amp;mut </span>ProgramErrors) {
    <span class="kw">let </span>Rule { lhs: active_pair, rhs: rule_rhs, span } = rule;

    <span class="kw">let </span>ActivePair { lhs: lhs_agent, rhs: rhs_agent } = active_pair;
    <span class="kw">let </span>lhs_id = <span class="self">self</span>.agent_name_to_id[<span class="kw-2">&amp;</span>lhs_agent.agent];
    <span class="kw">let </span>rhs_id = <span class="self">self</span>.agent_name_to_id[<span class="kw-2">&amp;</span>rhs_agent.agent];

    <span class="comment">// Construct RuleLhs, ordered pair of AgentIDs. Order agents along with AgentIDs
    </span><span class="kw">let </span>((lhs_id, lhs_agent), (rhs_id, rhs_agent)) =
      sort_tuples_by_fst(((lhs_id, lhs_agent), (rhs_id, rhs_agent)));
    <span class="kw">let </span>key = (lhs_id, rhs_id); <span class="comment">// Ordered pair

    </span><span class="kw">let </span>value = RuleRhs {
      rule_src: rule_src.to_owned(),
      port_idx_to_name: [
        lhs_agent.ports.iter().map(|port_name| port_name.to_owned()).collect_vec(),
        rhs_agent.ports.iter().map(|port_name| port_name.to_owned()).collect_vec(),
      ],
      connections: rule_rhs.clone(),
    };
    <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw">_</span>) = <span class="self">self</span>.rules.insert(key, value) {
      errors.push(Rich::custom(<span class="kw-2">*</span>span, <span class="macro">format!</span>(<span class="string">&quot;Duplicate rule for active pair `{active_pair}`&quot;</span>)));
    }
  }

  <span class="doccomment">/// Apply rule to active pair if such a rule exists
  /// Returns indices of created nodes if a rule was applied, None otherwise
  </span><span class="kw">pub fn </span>apply(<span class="kw-2">&amp;</span><span class="self">self</span>, net: <span class="kw-2">&amp;mut </span>INet, active_pair: (NodeIdx, NodeIdx)) -&gt; <span class="prelude-ty">Option</span>&lt;CreatedNodes&gt; {
    <span class="kw">let </span>(node_idx_lhs, node_idx_rhs) = active_pair;
    <span class="kw">let </span>(lhs_node, rhs_node) = (<span class="kw-2">&amp;</span>net[node_idx_lhs], <span class="kw-2">&amp;</span>net[node_idx_rhs]);
    <span class="kw">let </span>(lhs_id, rhs_id) = (lhs_node.agent_id, rhs_node.agent_id);

    <span class="comment">// Construct RuleLhs, ordered pair of AgentIDs. Order nodes along with AgentIDs
    </span><span class="kw">let </span>((lhs_id, lhs_node), (rhs_id, rhs_node)) =
      sort_tuples_by_fst(((lhs_id, lhs_node), (rhs_id, rhs_node)));
    <span class="kw">let </span>key = (lhs_id, rhs_id); <span class="comment">// Ordered pair

    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(RuleRhs { rule_src, port_idx_to_name, connections }) = <span class="self">self</span>.rules.get(<span class="kw-2">&amp;</span>key) {
      <span class="comment">// Build `external_links` (pairs of port name and NodePort)
      // based on all auxiliary ports in the active pair, e.g. if the rule LHS
      // is Add(ret, a) ~ Succ(b), the ports {ret, a, b} are external links, then
      // `INet::add_connections` looks up ports when adding the connections of the RHS sub-net
      </span><span class="kw">let </span>external_links = [lhs_node, rhs_node]
        .into_iter()
        .zip(port_idx_to_name)
        .flat_map(|(node, port_idx_to_name)| {
          <span class="macro">debug_assert_eq!</span>(
            node.ports.len(),
            port_idx_to_name.len() + <span class="number">1</span>,
            <span class="string">&quot;\n{net:#?}\n{rule_src}\n{node:?}, {port_idx_to_name:?}&quot;
          </span>);

          <span class="comment">// Skip principal port, only auxiliary ports have names
          </span>node
            .ports
            .iter()
            .skip(<span class="number">1</span>)
            .zip(port_idx_to_name)
            .map(|(<span class="kw-2">&amp;</span>node_port, port_name)| [<span class="prelude-val">Err</span>(port_name.as_str()), <span class="prelude-val">Ok</span>(node_port)])
        })
        .collect();
      <span class="prelude-val">Some</span>(net.add_connections(connections, external_links, <span class="kw-2">&amp;</span><span class="self">self</span>.agent_name_to_id))
    } <span class="kw">else </span>{
      <span class="prelude-val">None
    </span>}
  }
}
</code></pre></div></section></main></body></html>